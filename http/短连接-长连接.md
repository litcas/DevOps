- [HTTP 短链接与长连接](#http-短链接与长连接)
  - [1. 短连接](#1-短连接)
  - [2. 长连接](#2-长连接)
  - [3. 长连接与短连接的区别](#3-长连接与短连接的区别)
  - [4. HTTP 长连接实例](#4-http-长连接实例)
  - [5. 优缺点](#5-优缺点)
  - [6. 长连接 / 短连接的选择](#6-长连接--短连接的选择)
  - [7. Refer Links](#7-refer-links)

# HTTP 短链接与长连接

在 OSI 模型中，HTTP 处于应用层，依赖于传输层 TCP，因此 **HTTP 长连接和短连接本质上指的是 TCP 的长连接和短连接**。

**TCP 短连接在三次握手建立后，一般只会在 client/server 间传递一次读写操作，然后通过四次挥手关闭连接；TCP 长连接在三次握手建立后，会在 client/server 间传递多次读写操作，直到有一方主动结束或者连接超时，才通过四次挥手关闭连接**。

## 1. 短连接

**HTTP 短连接是指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送**。

**在 HTTP/1.0 中，默认使用的是短连接。浏览器和服务器每进行一次 HTTP 操作就建立一次连接，然后请求结束就直接中断连接**。一个普通页面如果有近百个 Web 资源（JavaScript、CSS、图片），那么浏览器每请求一次资源都会新建一个 HTTP 会话，每次会创建一个 TCP 连接，那么每次都要经历 TCP 的三次握手和四次挥手。在 HTTP 短连接的状态下，浏览器和我们的 Web 服务器重复的进行这样的操作：建立连接–>数据传输–>关闭连接。

## 2. 长连接

**从 HTTP/1.1 开始，默认使用长连接，即在请求头部中添加字段 connection:keep-alive，且主流浏览器和 Web 服务器默认情况下都使用的是 HTTP/1.1**。

长连接的建立需要客户端和服务端都支持。

P.S. HTTP 协议的无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态，即打开一个服务器上的网页和之前打开这个服务器上的网页之间没有任何联系。但注意，**无状态不代表 HTTP 不能保持 TCP 连接，保持 TCP 连接指的是客户端的多次 HTTP 请求使用同一个 TCP 连接，但多次请求之间没有任何状态的保持**。

## 3. 长连接与短连接的区别

![image](http://img.cdn.firejq.com/jpg/2018/1/23/0f35a193b519097c44e515f6d72d15a2.jpg)

## 4. HTTP 长连接实例

1. 客户端向 web 服务器发起请求，请求头部默认包含字段 keep-alive，即告诉 Web 服务器，“我要使用长连接”：

   ![image](http://img.cdn.firejq.com/jpg/2018/1/23/db7c495dc6aaf4f7c5e1f64b40aaf6ad.jpg)

1. web 服务器为 nginx，默认开启了长连接，在配置文件中可配置长连接超时时间，此处为 60 秒：
    ```
    keepalive_timeout 60;
    ```
    服务器响应，确认使用长连接：
    ![image](http://img.cdn.firejq.com/jpg/2018/1/23/7da7df08e0d98a517d09b3edd6987c17.jpg)

1. 此次请求响应结束后，客户端和服务器之间传输 HTTP 数据的 TCP 连接不会关闭<!--TODO: 那什么时候才会关闭 -->，如果客户端再次访问这个服务器上的资源，会继续使用这条已经建立的连接。

    在长连接的情况下，查看服务器的 TCP 连接可以看到一个 TCP 的 socket，状态是 ESTABLISHED：
    ```shell
    #netstat -na | grep  192.168.99.159:80
    tcp        0     0 192.168.99.159:80       192.168.99.50:24584     ESTABLISHED
    ```

1. 过了 60 秒之后，再次查看这个 socket 的状态，会发现已经转变为 TIME_WAIT
    ```shell
    #netstat -na | grep  192.168.99.159:80
    tcp        0     0 192.168.99.159:80      192.168.99.50:24584    TIME_WAIT
    ```
    在 Linux 系统中 TIME_WAIT 状态会持续 60 秒，在这期间这个 Socket 不会被释放；

因此，客户端访问服务器每发起一个 HTTP 长连接请求，在 Web 服务器端会占用一个 Socket 的连接，加上 TCP 建立连接的时间要 120 多秒。

## 5. 优缺点

- 优点

  避免了频繁的建立和销毁 TCP 连接，降低网络阻塞，提高了资源请求的速度。

- 缺点

  在高并发环境下，web 服务器需要维护大量的 socket 连接，耗费大量系统资源 -- 需要调整 `keepalive_timeout` 来改善（长连接的状态下，一个 Socket 的存在时间是建立 TCP 连接时间 + `keepalive_timeout` 时间 + `TIME_WAIT` 时间）。

## 6. 长连接 / 短连接的选择

实例：
- 数据库的连接一般会用长连接，因为如果用短连接频繁的通信会造成 socket 错误，而且频繁的 socket 创建也是对资源的浪费。
     
- WEB 网站的 HTTP 服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像 WEB 网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，压力可想而知。所以并发量大，但每个用户无需频繁操作的情况下需用短连好。

## 7. Refer Links

## 关于长连接和短连接的理解及使用场景


### 定义
短连接：例如普通的web请求，在三次握手之后建立连接，发送数据包并得到服务器返回的结果之后，通过客户端和服务端的四次握手进行关闭断开。
长连接：区别与短连接，由于三次握手连接及四次握手断开，在请求频繁的情况下，链接请求和断开请求开销较大，影响效率。采用长连接方式，执行三次握手链接后，不断开链接，保持客户端和服务端通信，直到服务器超时自动断开链接，或者客户端主动断开链接。

适用场景
短连接：适用于网页浏览等数据刷新频度较低的场景。
长连接：适用于客户端和服务端通信频繁的场景，例如聊天室，实时游戏。

官网定义什么是长连接
HTTP1.1规定了默认保持长连接（HTTP persistent connection ，也有翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据；相反的就是短连接。

HTTP首部的Connection: Keep-alive是HTTP1.0浏览器和服务器的实验性扩展，当前的HTTP1.1 RFC2616文档没有对它做说明，因为它所需要的功能已经默认开启，无须带着它，但是实践中可以发现，浏览器的报文请求都会带上它。

在实际使用中，HTTP头部有了Keep-Alive这个值并不代表一定会使用长连接，客户端和服务器端都可以无视这个值，也就是不按标准来，譬如我自己写的HTTP客户端多线程去下载文件，就可以不遵循这个标准，并发的或者连续的多次GET请求，都分开在多个TCP通道中，每一条TCP通道，只有一次GET，GET完之后，立即有TCP关闭的四次握手，这样写代码更简单，这时候虽然HTTP头有Connection: Keep-alive，但不能说是长连接。

长连接的过期时间
客户端的长连接不可能无限期的拿着，会有一个超时时间，服务器有时候会告诉客户端超时时间，譬如：
Keep-Alive: timeout=20，表示这个TCP通道可以保持20秒。另外还可能有max=XXX，表示这个长连接最多接收XXX次请求就断开。
对于客户端来说，如果服务器没有告诉客户端超时时间也没关系，服务端可能主动发起四次握手断开TCP连接，客户端能够知道该TCP连接已经无效。

长连接的数据传输完成识别
使用长连接之后，客户端、服务端怎么知道本次传输结束呢？
1是判断传输数据是否达到了Content-Length指示的大小；
2动态生成的文件没有Content-Length，它是分块传输（chunked），这时候就要根据chunked编码来判断，chunked编码的数据在最后有一个空chunked块，表明本次传输数据结束。

并发连接数的数量限制
在web开发中需要关注浏览器并发连接的数量，RFC文档说，客户端与服务器最多就连上两通道，但服务器、个人客户端要不要这么做就随人意了，有些服务器就限制同时只能有1个TCP连接，导致客户端的多线程下载（客户端跟服务器连上多条TCP通道同时拉取数据）发挥不了威力，有些服务器则没有限制。浏览器客户端就比较规矩，知乎这里有分析，限制了同域名下能启动若干个并发的TCP连接去下载资源。浏览器只对同域名下的并发连接做了限制，也就意味着，web开发者可以把资源放到不同域名下，同时也把这些资源放到不同的机器上，这样就完美解决了。

容易混淆的概念——TCP的keep alive和HTTP的Keep-alive
TCP的keep alive是检查当前TCP连接是否活着；HTTP的Keep-alive是要让一个TCP连接活久点。
TCP keep alive的表现：
当一个连接“一段时间”没有数据通讯时，一方会发出一个心跳包（Keep Alive包），如果对方有回包则表明当前连接有效，继续监控。

HTTP 流水线技术
使用了HTTP长连接（HTTP persistent connection ）之后的好处，包括可以使用HTTP 流水线技术。
它是指，在一个TCP连接内，多个HTTP请求可以并行，下一个HTTP请求在上一个HTTP请求的应答完成之前就发起。

============================================

绝大多数的分布式服务框架(RPC框架）都推荐使用长连接进行内部通信，原因如下：
1，相比于短连接，长连接更节省资源。如果每发送一条消息就要创建链路，发起握手认证，关闭链路释放资源，会损耗大量的系统资源。长连接只在首次创建时或者链路重连才创建链路，链路创建成功之后服务提供者和消费者会通过业务消息和心跳维系链路，实现多消息复用同一个链路节省资源。
2，远程通信是常态，调用时延是关键指标。服务化之后，本地API调用变成了远程服务调用，大量本地方法演化成了跨进程通信，网络时延成为关键指标之一。
